# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ReservoirCapacityChange
                                 A QGIS plugin
 Lake & Reservoir Capacity Change Estimator is a QGIS plugin designed to estimate the initial and final capacity of lakes and reservoirs, enabling the assessment of capacity change over time. This tool is particularly useful for sedimentation analysis by quantifying storage loss. It generates elevation-capacity and area-elevation graphs and provides volumetric variations at different water levels. Additionally, the plugin includes an optional feature to crop the lake raster using a vector extent layer for more precise analysis.

 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-03-02
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Sparsh Shekhar
        email                : 22m0587@iitb.ac.in
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
import sys
import inspect
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction

from qgis.core import (
    QgsProcessingAlgorithm, QgsProcessingParameterFile,
    QgsProcessingParameterRasterLayer, QgsProcessingParameterVectorLayer,
    QgsProcessingParameterBoolean, QgsProcessingParameterFileDestination,
    QgsProcessingParameterEnum, QgsProcessingParameterNumber,QgsRasterLayer, QgsProject, 
    QgsColorRampShader, QgsRasterRenderer, QgsRasterShader, QgsSingleBandPseudoColorRenderer
)
from osgeo import gdal, ogr
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from PyQt5.QtGui import QColor
import csv
import os

def clip_raster_with_vector(raster_path, vector_path, output_path):
    vector_ds = ogr.Open(vector_path)
    vector_layer = vector_ds.GetLayer()

    raster_ds = gdal.Open(raster_path)
    output_ds = gdal.Warp(output_path, raster_ds, cutlineDSName=vector_path, cropToCutline=True, dstNodata=-1)
    output_ds = None  # Save and close output
    return output_path


    
class ReservoirCapacityChange(QgsProcessingAlgorithm):
    def initAlgorithm(self, config=None):
        # Inputs from Case 1 (CSV Analysis)
        self.addParameter(QgsProcessingParameterFile("INPUT_CSV", "Initial Elevation-Capacity CSV (Two Columns: Water Elevation and Cumulative Volume)", extension="csv"))
        
        # Inputs from Case 2 (Raster Analysis)
        self.addParameter(QgsProcessingParameterRasterLayer("INPUT_RASTER", "Final Elevation Raster (Value in Meters)"))
        self.addParameter(QgsProcessingParameterVectorLayer("MASK_VECTOR", "Vector Mask Boundary ", optional=True))

        self.addParameter(QgsProcessingParameterBoolean("SKIP_OUTPUT", "Skip Output", defaultValue=False))
        self.addParameter(QgsProcessingParameterNumber("INCREMENT", "Depth Interval Increment", type=QgsProcessingParameterNumber.Double, minValue=0.001, defaultValue=0.01))


        # Common Outputs
        self.addParameter(QgsProcessingParameterFileDestination("OUTPUT_CSV1", "Output Initial Capacity", "CSV Files (*.csv)"))
        self.addParameter(QgsProcessingParameterFileDestination("OUTPUT_CSV2", "Output Final Capacity", "CSV Files (*.csv)"))
        self.addParameter(QgsProcessingParameterFileDestination("OUTPUT_COMBINED_CSV", "Output Capacity Change", "CSV Files (*.csv)"))

        # **New Output: Depth Difference Raster**
        self.addParameter(QgsProcessingParameterFileDestination("OUTPUT_RASTER", "Output Depth Difference Raster", "GeoTIFF Files (*.tif)"))


        # Area Unit
        self.addParameter(QgsProcessingParameterEnum("OUTPUT_UNIT", "Area Output Unit", options=["km²"], defaultValue=0))


    def generate_depth_difference_raster(self, raster_array, new_df):
        """ Generates a depth difference raster using the provided DataFrame """
        depth_diff_raster = np.full_like(raster_array, np.nan)  # Initialize with NaN

        # Convert dataframe columns to NumPy arrays for faster processing
        E1_arr = new_df["E1"].values
        E2_arr = new_df["E2"].values
        depth_diff_arr = new_df["Depth Difference"].values

        # Apply depth difference mapping using vectorized NumPy operations
        for i in range(len(E1_arr)):
            mask = (raster_array >= E1_arr[i]) & (raster_array <= E2_arr[i])
            depth_diff_raster[mask] = depth_diff_arr[i]

        return depth_diff_raster
        
        
    def processAlgorithm(self, parameters, context, feedback):
        # Read Inputs
        input_csv = self.parameterAsFile(parameters, "INPUT_CSV", context)
        input_raster = self.parameterAsRasterLayer(parameters, "INPUT_RASTER", context)
        mask_vector = self.parameterAsVectorLayer(parameters, "MASK_VECTOR", context)
        increment = self.parameterAsDouble(parameters, "INCREMENT", context)
        skip_output = self.parameterAsBoolean(parameters, "SKIP_OUTPUT", context)
        output_unit = self.parameterAsEnum(parameters, "OUTPUT_UNIT", context)

        output_csv1 = self.parameterAsFile(parameters, "OUTPUT_CSV1", context)
        output_csv2 = self.parameterAsFile(parameters, "OUTPUT_CSV2", context)
        output_combined_csv = self.parameterAsFile(parameters, "OUTPUT_COMBINED_CSV", context)
        
        output_raster_path = self.parameterAsFile(parameters, "OUTPUT_RASTER", context)
        # Process CSV Analysis (Case 1)
        feedback.pushInfo("Processing Initial Capacity Analysis (CSV)...")

        df1 = pd.read_csv(input_csv)

        if "Water Elevation" not in df1.columns or "Cumulative Volume" not in df1.columns:
            raise ValueError("CSV must contain 'Water Elevation' and 'Cumulative Volume' columns")

        df1["Water Elevation"] = df1["Water Elevation"].astype(float)
        df1["Cumulative Volume"] = df1["Cumulative Volume"].astype(float)

        # Initialize columns
        df1["Volume (Million m³)"] = 0.0
        df1["Area (km²)"] = 0.0
        df1["Water Level from Bottom"] = 0.0

        # Calculate Volume (Difference between consecutive rows of Cumulative Volume)
        df1["Volume (Million m³)"] = df1["Cumulative Volume"].diff().fillna(0)

        # Calculate Water Level from Bottom (first row is zero, rest increment by elevation difference)
        df1["Water Level from Bottom"] = df1["Water Elevation"] - df1["Water Elevation"].iloc[0]

        # Area calculation using reverse prismoidal formula
        df1["Area (m²)"] = 0.0 
        df1["Area (km²)"] = 0.0
        for i in range(1, len(df1)):
            elevation_diff = df1["Water Elevation"].iloc[i] - df1["Water Elevation"].iloc[i-1]
            volume = df1["Volume (Million m³)"].iloc[i] * 1e6  # Convert to m³
            if i == 1:
                # First non-zero area from first real elevation difference
                df1.at[i, "Area (m²)"] = volume / elevation_diff
            else:
                # Reverse prismoidal - estimate next area from volumes and height difference
                prev_area = df1["Area (m²)"].iloc[i-1]
                df1.at[i, "Area (m²)"] = (3 * volume / elevation_diff - prev_area) / 2

        # Convert to km² if needed
        if output_unit == 0:  # km²
            df1["Area (km²)"] = df1["Area (m²)"] / 1e6
        else:
            df1["Area (km²)"] = df1["Area (m²)"]

        # Generate Charts
        chart_path_capacity = output_csv1.replace('.csv', '_initial_capacity.png')
        chart_path_area = output_csv1.replace('.csv', '_initial_area.png')

        self.generate_initial_capacity_chart(chart_path_capacity, df1)
        self.generate_initial_area_chart(chart_path_area, df1)

        # Add chart paths to the output CSV for reference
        df1["Chart Path"] = ""
        df1.loc[0, "Chart Path"] = chart_path_capacity
        df1.loc[1, "Chart Path"] = chart_path_area

        # Save result to CSV
        df1.drop(columns=["Area (m²)"]).to_csv(output_csv1, index=False)

        
        
        
        
        
        
        
        
        
        
        
        

        # Process Raster Analysis (Case 2)............................................................................................
        feedback.pushInfo("Processing Final Capacity Analysis (Elevation Raster)...")





        if not input_raster or not input_raster.isValid():
            raise ValueError("Invalid raster file")

        raster_path = input_raster.source()
        clipped_raster_path = raster_path

        if mask_vector:
            clipped_raster_path = raster_path.replace('.tif', '_clipped.tif')
            clipped_raster_path = clip_raster_with_vector(raster_path, mask_vector.source(), clipped_raster_path)

        dataset = gdal.Open(clipped_raster_path)
        band = dataset.GetRasterBand(1)
        raster_array = band.ReadAsArray().astype(np.float32)

        no_data_value = band.GetNoDataValue()
        if no_data_value is not None:
            raster_array[raster_array == no_data_value] = np.nan

        min_elevation = np.nanmin(raster_array)
        max_value = np.nanmax(raster_array)
        max_extra = max_value + 0.0000001
        raster_array = max_extra - raster_array

        min_value = np.nanmin(raster_array)
        max_value = np.nanmax(raster_array)
        count_valid_pixels = np.sum(~np.isnan(raster_array))

        geo_transform = dataset.GetGeoTransform()
        pixel_size_x, pixel_size_y = geo_transform[1], -geo_transform[5]
        mean_resolution = (pixel_size_x + pixel_size_y) / 2

        depth_intervals = np.arange(min_value, max_value + increment, increment)
        depth_counts = [(depth, np.sum(raster_array >= depth)) for depth in depth_intervals]

        depth_data = [(depth, count, (count * mean_resolution**2) / 1e6) for depth, count in depth_counts]
        depth_data.reverse()

        volume_data = [0]
        for i in range(len(depth_data) - 1):
            h = increment
            A1 = depth_data[i][2]
            A2 = depth_data[i + 1][2]
            A_mid = (A1 * A2) ** 0.5
            volume = (h / 6) * (A1 + 4 * A_mid + A2)
            volume_data.append(volume)

        cumulative_volume_data = [0]
        for i in range(1, len(volume_data)):
            cumulative_volume_data.append(cumulative_volume_data[i - 1] + volume_data[i])

        first_depth_interval = depth_data[0][0]
        depth_data = [(depth, count, area, vol, cum_vol, float(first_depth_interval - depth))
                      for (depth, count, area), vol, cum_vol
                      in zip(depth_data, volume_data, cumulative_volume_data)]

        depth_data = [(depth, count, area, vol, cum_vol, wl, wl + min_elevation)
                      for (depth, count, area, vol, cum_vol, wl) in depth_data]

        if skip_output:
            feedback.pushInfo(f"Pixel Size X: {pixel_size_x}")
            feedback.pushInfo(f"Pixel Size Y: {pixel_size_y}")
            feedback.pushInfo(f"Mean Resolution: {mean_resolution}")
            return {}

        chart_path = output_csv2.replace('.csv', '_final_capacity.png')
        chart_path2 = output_csv2.replace('.csv', '_final_area.png')
        
        df2 = pd.DataFrame(depth_data, columns=[
            "Depth Interval", "Pixel Count", "Area (km²)",
            "Volume (Million m³)", "Cumulative Volume (Million m³)",
            "Water Level from Bottom", "Water Elevation from Bottom"
        ])

        df2.rename(columns={
            "Area (km²)": "Area (km²)",
            "Cumulative Volume (Million m³)": "Cumulative Volume (Million m³)",
            "Volume (Million m³)": "Volume (Million m³)",
            "Water Elevation from Bottom": "Water Elevation"
        }, inplace=True)

        df2["Chart Path"] = ""

        self.generate_cumulative_volume_chart(chart_path, df2)
        self.generate_area_chart(chart_path2, df2)

        df2.loc[0, "Chart Path"] = chart_path
        df2.loc[1, "Chart Path"] = chart_path2

        df2 = df2[[
            "Water Elevation",
            "Cumulative Volume (Million m³)",
            "Volume (Million m³)",
            "Pixel Count",
            "Area (km²)",
            "Water Level from Bottom",
            "Depth Interval",
            "Chart Path"
        ]]        
        
        
        

        df2.to_csv(output_csv2, index=False)

        # Combine Analysis - Combined CSV (Case 3).............................................................................
        feedback.pushInfo("Generating Capacity Change Report...")


        combined_data = []

        for elev in df1["Water Elevation"]:
            # Find closest elevation in df2
            closest_index = (df2["Water Elevation"] - elev).abs().argmin()
            row1 = df1.iloc[(df1["Water Elevation"] - elev).abs().argmin()]  # Row from df1 (exact match to elev)
            row2 = df2.iloc[closest_index]  # Closest matching row from df2

            combined_data.append([
                elev,  # The target elevation from df1
                row1["Cumulative Volume"],  # Capacity from df1
                row2["Cumulative Volume (Million m³)"],  # Closest match from df2
                row1["Cumulative Volume"] - row2["Cumulative Volume (Million m³)"],  # Difference
                row1["Area (km²)"],
                row2["Area (km²)"],
                #row1["Area (km²)"] - row2["Area (km²)"]
            ])

        chart_capacity_change = output_combined_csv.replace('.csv', '_capacity_change.png')
        
        df_combined = pd.DataFrame(combined_data, columns=[
            "Water Elevation", "Initial Capacity", "Final Capacity", "Capacity Change", "Initial Area", "Final Area"
        ])

        df_combined["Chart Path"] = ""

        self.generate_capacity_change_chart(chart_capacity_change, df_combined)


        df_combined.loc[0, "Chart Path"] = chart_capacity_change


        df_combined = df_combined[[
            "Water Elevation", "Initial Capacity", "Final Capacity", "Capacity Change","Initial Area", "Final Area","Chart Path"
        ]]    

        df_combined.to_csv(output_combined_csv, index=False)

        # Initialize a new list to store transformed data
        transformed_data = []

        # Loop through the dataframe row-wise
        for i in range(len(df_combined) - 1):
            E1 = df_combined.loc[i, "Water Elevation"]
            E2 = df_combined.loc[i + 1, "Water Elevation"]
            SED = df_combined.loc[i + 1, "Capacity Change"] - df_combined.loc[i, "Capacity Change"]
            A1 = df_combined.loc[i + 1, "Initial Area"] - df_combined.loc[i, "Initial Area"]
            A2 = df_combined.loc[i + 1, "Final Area"] - df_combined.loc[i, "Final Area"]
            
            # Calculate Depth Difference using prismoidal formula reversal
            if A1 > 0 and A2 > 0:
                A_mid = (A1 * A2) ** 0.5  # Geometric mean of A1 and A2
                Depth_Difference = 1*(6 * SED) / (A1 + 4 * A_mid + A2)
            elif A1 == 0 or A2 == 0:
                A_mid = (A1 * A2) ** 0.5  # Geometric mean of A1 and A2
                Depth_Difference = (SED) / (A1 + 4 * A_mid + A2)
            else:
                Depth_Difference = 0  # Handle cases where area values are zero or invalid
            
            transformed_data.append([E1, E2, SED, A1, A2, Depth_Difference])

        # Create a new DataFrame
        new_df = pd.DataFrame(transformed_data, columns=["E1", "E2", "SED", "A1", "A2", "Depth Difference"])
        
        
        
        
        
        
        dataset2 = gdal.Open(input_raster.source())
        raster_band2 = dataset2.GetRasterBand(1)
        raster_array2 = raster_band2.ReadAsArray()


        
        
        # Convert raster values to depth differences
        feedback.pushInfo("Generating depth difference raster...")
        depth_difference_raster = self.generate_depth_difference_raster(raster_array2, new_df)

        # Save the new depth difference raster
        feedback.pushInfo(f"Saving depth difference raster to {output_raster_path}...")
        driver = gdal.GetDriverByName("GTiff")
        out_dataset = driver.Create(output_raster_path, dataset.RasterXSize, dataset.RasterYSize, 1, gdal.GDT_Float32)
        out_dataset.SetGeoTransform(dataset.GetGeoTransform())
        out_dataset.SetProjection(dataset.GetProjection())
        out_band = out_dataset.GetRasterBand(1)
        out_band.WriteArray(depth_difference_raster)
        out_band.SetNoDataValue(np.nan)
        out_band.FlushCache()
        out_dataset = None  # Close dataset
        

    
    
    

        feedback.pushInfo("All processing complete!")
        
        return {
            "OUTPUT_CSV1": output_csv1,
            "OUTPUT_CSV2": output_csv2,
            "OUTPUT_COMBINED_CSV": output_combined_csv,
            "OUTPUT_RASTER": output_raster_path
        }

       
        # Load the new raster into the QGIS layer panel
        layer_name = "Depth Difference Raster"
        qgis_layer = QgsRasterLayer(output_raster_path, layer_name, "gdal")

        if not qgis_layer.isValid():
            feedback.reportError("Failed to load the depth difference raster into QGIS.")
        else:
            QgsProject.instance().addMapLayer(qgis_layer)
            feedback.pushInfo("Depth difference raster successfully added to QGIS layer panel.")
     


   
   
    def generate_initial_capacity_chart(self, chart_path_capacity, df1):
        plt.figure(figsize=(6, 4))
        plt.plot(df1["Cumulative Volume"], df1["Water Elevation"], marker='o', linestyle='-', color='b')
        plt.xlabel("Cumulative Volume (Million m³)")
        plt.ylabel("Water Elevation (m)")
        plt.title("Elevation vs Cumulative Volume")
        plt.grid(True)
        plt.savefig(chart_path_capacity)
        plt.close()

    def generate_initial_area_chart(self, chart_path_area, df1):
        plt.figure(figsize=(6, 4))
        plt.plot(df1["Area (km²)"], df1["Water Elevation"], marker='o', linestyle='-', color='b')
        plt.xlabel("Area (km²)")
        plt.ylabel("Water Elevation (m)")
        plt.title("Elevation vs Area")
        plt.grid(True)
        plt.savefig(chart_path_area)
        plt.close()
        
    def generate_cumulative_volume_chart(self, chart_path, df2):
        plt.figure(figsize=(6, 4))
        plt.plot(df2["Cumulative Volume (Million m³)"], df2["Water Elevation"], marker='o', linestyle='-', color='b')
        plt.xlabel("Cumulative Volume (Million m³)")
        plt.ylabel("Water Elevation (m)")
        plt.title("Cumulative Volume vs Water Elevation")
        plt.grid(True)
        plt.savefig(chart_path)
        plt.close()

    def generate_area_chart(self, chart_path2, df2):
        plt.figure(figsize=(6, 4))
        plt.plot(df2["Area (km²)"], df2["Water Elevation"], marker='o', linestyle='-', color='g')
        plt.xlabel("Area (km²)")
        plt.ylabel("Water Elevation (m)")
        plt.title("Area vs Water Elevation")
        plt.grid(True)
        plt.savefig(chart_path2)
        plt.close()


    def generate_capacity_change_chart(self, chart_capacity_change, df_combined):
        plt.figure(figsize=(8, 8))

        # Initial Capacity - Blue Line
        plt.plot( df_combined["Initial Capacity"], df_combined["Water Elevation"],
                 marker='o', linestyle='-', color='b', label='Initial Capacity')

        # Final Capacity - Red Line
        plt.plot( df_combined["Final Capacity"], df_combined["Water Elevation"],
                 marker='o', linestyle='-', color='r', label='Final Capacity')

        # Capacity Change - Green Dotted Line with Triangle Marker
        #plt.plot( df_combined["Capacity Change"],df_combined["Water Elevation"], marker='*', linestyle='--', color='g', label='Capacity Change')

        # Labels, Title, Grid
        plt.xlabel("Cumulative Capacity (Million m³)")
        plt.ylabel("Water Elevation (m)")
        plt.title("  Elevation vs Cumulative Capacity")
        plt.grid(True)

        # Add Legend
        plt.legend()

        # Save and Close Plot
        plt.savefig(chart_capacity_change)
        plt.close()



        
    def name(self):
        return "Lake & Reservoir Capacity Change Estimator"

    def displayName(self):
        return "Lake & Reservoir Capacity Change (Sedimentation) Estimator"


    def group(self):
        return self.tr(self.groupId())

    def icon(self):       
        return QIcon(os.path.join(os.path.dirname(__file__), "icon.png"))

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)
        
    def shortHelpString(self):
        return self.tr("""
                        Outputs:
                            Generates Initial and Final Elevation-Capacity Curves in .png format.
                            Produces .csv files containing Initial Capacity, Final Capacity and Capacity Change values at different elevations.
                            The capacity change analysis aids in sedimentation estimation for lakes and reservoirs.
                            
                        Input Initial csv Requirement:
                            Two Columns needed which are Water Elevation and Cumulative Volume 
                            Units of Water Elevation must be in meters and Cumulative Volume must be in Million cubic meter. 
                        CRS Requirement:
                            Both the raster and the vector mask (if used) must be in a projected CRS to ensure accurate area and volume calculations.

                        Depth Interval Recommendation:
                            For more accurate capacity and capacity change estimations, use a smaller depth interval (e.g., 0.01 m or 0.001 m). This is crucial because the tool applies the prismoidal formula to calculate volumetric changes, which benefits from finer intervals.

                        Elevation Raster:
                            Elevation values must be in meters.
                            Reference Point: A fixed datum (e.g., mean sea level or WGS84).
                            Values:
                            Positive values represent lake floor elevations above mean sea level (e.g., +50 m).
                            Negative values represent lake floor elevations below mean sea level (e.g., -50 m).
                        """)     




    def createInstance(self):
        return ReservoirCapacityChange()

